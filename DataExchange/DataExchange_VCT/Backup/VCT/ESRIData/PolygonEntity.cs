///////////////////////////////////////////////////////////
//  PolygonEntity.cs
//  Implementation of the Class PolygonEntity
//  Generated by Enterprise Architect
//  Created on:      08-四月-2011 13:45:32
//  Original author: Administrator
///////////////////////////////////////////////////////////




using DIST.DGP.DataExchange.VCT.FileData;
using DIST.DGP.DataExchange.VCT.ESRIData;
using ESRI.ArcGIS.Geodatabase;
using ESRI.ArcGIS.Geometry;
using ESRI.ArcGIS.esriSystem;
using System;
using System.Collections.Generic;
using DIST.DGP.DataExchange.VCT.Metadata;
namespace DIST.DGP.DataExchange.VCT.ESRIData
{
    /// <summary>
    /// 多边形实体类
    /// </summary>
    public class PolygonEntity : FeatureEntity
    {

        public PolygonNode m_PolygonNode;

        public PolygonEntity()
        {

        }
        public PolygonEntity(EntityNode node)
        {
            this.Representation = node.Representation;
            this.FeatureCode = node.FeatureCode;
            this.EntityID = node.EntityID;
            //CreateFeature(node);
        }

        ~PolygonEntity()
        {

        }

        public override void Dispose()
        {
            base.Dispose();
        }

        /// <summary>
        /// 创建面实体
        /// </summary>
        /// <param name="pITable">数据表对象</param>
        /// <param name="entinyNode">VCT空间实体节点</param>
        public override void CreateFeature(ITable pITable, EntityNode entinyNode)
        {
            PolygonNode pPolygonNode = entinyNode as PolygonNode;
            if (pPolygonNode != null)
            {
                IFeatureClass pFeatureCls = pITable as IFeatureClass;
                this.Feature = pFeatureCls.CreateFeature();

                ///标识码赋值
                int dBSMIndex = -1;
                dBSMIndex = this.Feature.Fields.FindField(m_strEntityIDFiled);
                if (dBSMIndex != -1)
                    this.Feature.set_Value(dBSMIndex, pPolygonNode.EntityID);

                ///要素代码赋值
                int dSYDMIndex = -1;
                dSYDMIndex = this.Feature.Fields.FindField(m_strYSDMField);
                if (dSYDMIndex != -1)
                    this.Feature.set_Value(dSYDMIndex, pPolygonNode.FeatureCode);


                //根据面特征类型构面 
                bool bGetGeometry = false;///指示是否获取图形数据

                ///从配置表获取面的类型InDireCoordinatePolygon表示间接坐标构面
                if (Metadata.MetaDataFile.GraphConfig.GetGraphMark("POLYGONFEATURETYPE", pPolygonNode.PolygonType.ToString()) == "InDireCoordinatePolygon")
                {
                    IGeometryCollection pGeoCollection = new PolygonClass();
                    IPointCollection pPtCollection = new RingClass();

                    ///采用间接构面的方式LineStructPolygon表示引用线构面
                    if (Metadata.MetaDataFile.GraphConfig.GetGraphMark("POLYGONTYPE", pPolygonNode.ComposeType.ToString()) == "LineStructPolygon")
                    {
                        for (int i = 0; i < pPolygonNode.LineNodes.Count; i++)
                        {
                            LineNodeEx pLineNodeEx = pPolygonNode.LineNodes[i];
                            if (pLineNodeEx == null)
                                continue;
                           
                            ///标识码为0表示对象分割标识
                            if (pLineNodeEx.EntityID != 0)
                            {
                                IPoint pPrePoint=null;
                                if (pPtCollection.PointCount > 0)
                                    pPrePoint = pPtCollection.get_Point(pPtCollection.PointCount-1);
                                IPointCollection pPointCollection=GetPointCollection(pLineNodeEx, pPrePoint);
                                if (pPointCollection != null)
                                    pPtCollection.AddPointCollection(pPointCollection);
                                if (i == pPolygonNode.LineNodes.Count - 1)
                                {
                                    IRing pRing = pPtCollection as IRing;
                                    pRing.Close();///闭合当前环
                                    object oTypeMissing = Type.Missing;
                                    pGeoCollection.AddGeometry(pRing as IGeometry, ref oTypeMissing, ref oTypeMissing);
                                    bGetGeometry = true;
                                    pPtCollection = new RingClass();///清空点集数据
                                }
                            }
                            else///独到标识码为0时闭合图形
                            {
                                IRing pRing = pPtCollection as IRing;
                                pRing.Close();///闭合当前环
                                object oTypeMissing = Type.Missing;
                                pGeoCollection.AddGeometry(pRing as IGeometry, ref oTypeMissing, ref oTypeMissing);
                                bGetGeometry = true;
                                pPtCollection = new RingClass();///清空点集数据
                            }
                        }
                        if (bGetGeometry)
                        {
                            (this.Feature as IFeature).Shape = pGeoCollection as IGeometry;
                        }
                    }
                }
                else if (pPolygonNode.PolygonType == 1)
                {

                }


                this.Feature.Store();
            }
        }

        /// <summary>
        /// 根据vct线段获取点集合
        /// </summary>
        /// <param name="pLineNodeEx"></param>
        /// <returns></returns>
        private IPointCollection GetPointCollection(LineNodeEx pLineNodeEx, IPoint pPrePoint)
        {
            //沈迎志修改，注意线的方向
            try
            {
                IPointCollection pPtCollection = new PolylineClass();

                if (pLineNodeEx.IsReverse == false)
                {
                    for (int i = 0; i < pLineNodeEx.SegmentNodes.Count; i++)
                    {
                        BrokenLineNode pBLineNode = pLineNodeEx.SegmentNodes[i] as BrokenLineNode;
                        if (pBLineNode != null)
                        {
                            for (int j = 0; j < pBLineNode.PointInfoNodes.Count; j++)
                            {
                                if (i == 0 && j == 0 && pPrePoint != null)
                                    continue;

                                PointInfoNode itemInfoNode = pBLineNode.PointInfoNodes[j];
                                IPoint pPoint = new PointClass();
                                pPoint.PutCoords(itemInfoNode.X, itemInfoNode.Y);
                                object objTypemissing = Type.Missing;
                                pPtCollection.AddPoint(pPoint, ref objTypemissing, ref objTypemissing);
                            }
                        }
                    }
                }
                else
                {
                    for (int i = pLineNodeEx.SegmentNodes.Count - 1; i >= 0; i--)
                    {
                        BrokenLineNode pBLineNode = pLineNodeEx.SegmentNodes[i] as BrokenLineNode;
                        if (pBLineNode != null)
                        {
                            for (int j = pBLineNode.PointInfoNodes.Count - 1; j >= 0; j--)
                            {
                                if (i == pLineNodeEx.SegmentNodes.Count - 1 && j == pBLineNode.PointInfoNodes.Count - 1 && pPrePoint != null)
                                    continue;

                                PointInfoNode itemInfoNode = pBLineNode.PointInfoNodes[j];
                                IPoint pPoint = new PointClass();
                                pPoint.PutCoords(itemInfoNode.X, itemInfoNode.Y);
                                object objTypemissing = Type.Missing;
                                pPtCollection.AddPoint(pPoint, ref objTypemissing, ref objTypemissing);
                            }
                        }
                    }
                }


               /*               ///构造线段
                             for (int j = 0; j < pLineNodeEx.SegmentNodes.Count; j++)
                             {
                                 BrokenLineNode pBLineNode = pLineNodeEx.SegmentNodes[j] as BrokenLineNode;
                                 bool bNewBeginPoint = true;///表示正在处理折线的起点
                                 foreach (PointInfoNode itemInfoNode in pBLineNode.PointInfoNodes)
                                 {
                                     if (bNewBeginPoint&&pPrePoint != null && itemInfoNode.X == pPrePoint.X
                                         &&itemInfoNode.Y==pPrePoint.Y)
                                     {
                                         ///如果是前一个线段终点和后一个线段起点相同则不添加到构面点集合中
                                         continue;
                                     }
                                     ///将点添加到构线集合中
                                     IPoint pPoint = new PointClass();
                                     pPoint.PutCoords(itemInfoNode.X, itemInfoNode.Y);
                                     object objTypemissing = Type.Missing;
                                     pPtCollection.AddPoint(pPoint, ref objTypemissing, ref objTypemissing);
 
                                 }
                                 bNewBeginPoint = false;///当前的起点处理完成
                             }

                             if (pLineNodeEx.IsReverse)
                             {
                                 ///方向构造闭合环
                                 object objTypeMissing = Type.Missing;
                                 IPointCollection pPtReserveCollection = new RingClass();
                                 ///反向添加点集合数据
                                 for (int k = pPtCollection.PointCount; k >= 0; k--)
                                 {
                                     pPtReserveCollection.AddPoint(pPtCollection.get_Point(k), ref objTypeMissing, ref objTypeMissing);
                                 }
                                 return pPtReserveCollection;
                             }
             */
                return pPtCollection;
            }
            catch(Exception ex)
            {
                LogAPI.WriteErrorLog(ex);
                return null;
            }
        }

        /// <summary>
        /// 将构面的环分解成线段集合
        /// </summary>
        /// <param name="pRing">构面的环对象IRing</param>
        /// <param name="strFeatureCode">线的要素代码</param>
        /// <param name="strRepresentation">图形表现编码</param>
        /// <param name="nEntityID">面实体索引</param>
        /// <returns>VCT线段对象集合</returns>
        private List<LineNodeEx> GetLineNodeExsByRing(IRing pRing, string strFeatureCode, string strRepresentation, int nEntityID)
        {
            try
            {
                List<LineNodeEx> arrLineNodeEx = new List<LineNodeEx>();

                ///获取每个环中的线段集合
                IPointCollection pIPointCollection = pRing as IPointCollection;




                for (int i = 0; i < pIPointCollection.PointCount; i++)
                {
                    if (i > 0)
                    {
                        LineNodeEx pLineNodeEx = new LineNodeEx();//构造VCT线段对象
                        pLineNodeEx.SegmentNodes = new SegmentNodes();//构造线段对应的点集合
                        pLineNodeEx.FeatureCode = strFeatureCode;//设置要素代码
                        pLineNodeEx.Representation = strRepresentation;
                        pLineNodeEx.PolygonID = nEntityID;///所属面的标识码

                        BrokenLineNode pBrokenLinNode = new BrokenLineNode();//构造折线
                        pBrokenLinNode.PointInfoNodes = new PointInfoNodes();

                        IPoint pIPoint1 = pIPointCollection.get_Point(i - 1);
                        IPoint pIPoint2 = pIPointCollection.get_Point(i);
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pIPoint1.X, pIPoint1.Y));
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pIPoint2.X, pIPoint2.Y));
                        pLineNodeEx.SegmentNodes.Add(pBrokenLinNode);

                        arrLineNodeEx.Add(pLineNodeEx);
                    }
                }


                return arrLineNodeEx;
                /*
                ///处理集合中的各个线段
                for (int i = 0; i < pExRingSegmentCollection.SegmentCount; i++)
                {
                    ISegment pSegment = pExRingSegmentCollection.get_Segment(i);

                    LineNodeEx pLineNodeEx = new LineNodeEx();//构造VCT线段对象
                    pLineNodeEx.SegmentNodes = new SegmentNodes();//构造线段对应的点集合
                    //pLineNodeEx.IsReverse = bReverse;//设置方向
                    pLineNodeEx.FeatureCode = strFeatureCode;//设置要素代码
                    pLineNodeEx.Representation = strRepresentation;
                    pLineNodeEx.PolygonID = nEntityID;///所属面的标识码


                    BrokenLineNode pBrokenLinNode = new BrokenLineNode();//构造折线
                    pBrokenLinNode.PointInfoNodes = new PointInfoNodes();

                    ILine pLine = pSegment as ILine;
                    if (pLine != null)
                    {
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pLine.FromPoint.X, pLine.FromPoint.Y));
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pLine.ToPoint.X, pLine.ToPoint.Y));
                    }

                    //////如果是反向
                    ////if (bReverse)
                    ////{
                    ////    PointInfoNodes tempPointInfoNodes = new PointInfoNodes();
                    ////    foreach (PointInfoNode item in pBrokenLinNode.PointInfoNodes)
                    ////    {
                    ////        tempPointInfoNodes.Add(item);
                    ////    }
                    ////    pBrokenLinNode.PointInfoNodes = tempPointInfoNodes;
                    ////}
                    pLineNodeEx.SegmentNodes.Add(pBrokenLinNode);
                    pListLine.Add(pLineNodeEx);
                }

                return pListLine;*/
            }
            catch (Exception ex)
            {
                LogAPI.WriteErrorLog(ex);
                return null;
            }
        }

        /// <summary>
        /// 将构面的环分解成线段集合
        /// </summary>
        /// <param name="pRing">构面的环对象IRing</param>
        /// <param name="strFeatureCode">线的要素代码</param>
        /// <param name="strRepresentation">图形表现编码</param>
        /// <param name="nEntityID">面实体索引</param>
        /// <returns>VCT线段对象集合</returns>
        private List<LineNodeEx> GetLineByRing(IRing pRing,string strFeatureCode,string strRepresentation,int nEntityID)
        {
            try
            {
                List<LineNodeEx> pListLine = new List<LineNodeEx>();
               
                ///获取每个环中的线段集合
                ISegmentCollection pExRingSegmentCollection = pRing as ISegmentCollection;

                ///处理集合中的各个线段
                for (int i = 0; i < pExRingSegmentCollection.SegmentCount; i++)
                {
                    ISegment pSegment = pExRingSegmentCollection.get_Segment(i);

                    LineNodeEx pLineNodeEx = new LineNodeEx();//构造VCT线段对象
                    pLineNodeEx.SegmentNodes = new SegmentNodes();//构造线段对应的点集合
                    //pLineNodeEx.IsReverse = bReverse;//设置方向
                    pLineNodeEx.FeatureCode = strFeatureCode;//设置要素代码
                    pLineNodeEx.Representation = strRepresentation;
                    pLineNodeEx.PolygonID = nEntityID;///所属面的标识码


                    BrokenLineNode pBrokenLinNode = new BrokenLineNode();//构造折线
                    pBrokenLinNode.PointInfoNodes = new PointInfoNodes();

                    
                    ILine pLine = pSegment as ILine;
                    if (pLine != null)
                    {
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pLine.FromPoint.X, pLine.FromPoint.Y));
                        pBrokenLinNode.PointInfoNodes.Add(new PointInfoNode(pLine.ToPoint.X, pLine.ToPoint.Y));
                    }
                    

                    //////如果是反向
                    ////if (bReverse)
                    ////{
                    ////    PointInfoNodes tempPointInfoNodes = new PointInfoNodes();
                    ////    foreach (PointInfoNode item in pBrokenLinNode.PointInfoNodes)
                    ////    {
                    ////        tempPointInfoNodes.Add(item);
                    ////    }
                    ////    pBrokenLinNode.PointInfoNodes = tempPointInfoNodes;
                    ////}
                    pLineNodeEx.SegmentNodes.Add(pBrokenLinNode);
                    pListLine.Add(pLineNodeEx);
                }

                return pListLine;
            }
            catch(Exception ex)
            {
                LogAPI.WriteErrorLog(ex);
                return null;
            }
        }

        /// <summary>
        /// 获取VCT面实体节点
        /// </summary>
        public override EntityNode GetEntityNode()
        {
            try
            {
                m_PolygonNode = new PolygonNode();
                IFeature pFeature = this.Feature as IFeature;
                ///标识码赋值
                int dBSMIndex = -1;
                dBSMIndex = this.Feature.Fields.FindField(m_strEntityIDFiled);
                if (dBSMIndex != -1)
                    m_PolygonNode.EntityID = Convert.ToInt32(this.Feature.get_Value(dBSMIndex));

                ///图形表现赋值 
                 //m_PolygonNode.Representation = pFeature.Class.AliasName;

                ///要素代码赋值
                //int dSYDMIndex = -1;
                //dSYDMIndex = this.Feature.Fields.FindField(m_strYSDMField);
                //if (dSYDMIndex != -1)
                //    m_PolygonNode.FeatureCode = this.Feature.get_Value(dSYDMIndex).ToString();
                //string sAttriTableName = (pFeature.Class as IDataset).Name;
                //m_PolygonNode.FeatureCode = MetaDataFile.GetFeatureCodeByName(sAttriTableName);
                m_PolygonNode.FeatureCode = this.FeatureCode;

                //设置间接坐标面构成类型、面特征类型、图形表现代码
                m_PolygonNode.PolygonType = 100;
                //m_PolygonNode.Representation = pFeature.Class.AliasName;

                ///add by 曾平 2011-9-7 添加裁切
                IGeometry pFeatureGeometry = null;
                if (m_bCut)
                {
                     pFeatureGeometry = GetSubGeometry();
                    if (pFeatureGeometry == null)
                    {
                        pFeatureGeometry = pFeature.Shape;
                    }
                }
                else
                {
                    pFeatureGeometry = pFeature.Shape;
                }

                IPolygon4 pGeoPolygon = pFeatureGeometry as IPolygon4;
                List<LineNodeEx> pListNodeEx = new List<LineNodeEx>();

                IGeometryBag pExteriorRings = pGeoPolygon.ExteriorRingBag;
                ///获取外环集合
                IEnumGeometry pExteriorRingsEnum = pExteriorRings as IEnumGeometry;
                pExteriorRingsEnum.Reset();
                IRing pCurrentExteriorRing = pExteriorRingsEnum.Next() as IRing;

                ////构面的线段要素代码都是面的要素代码
                string strLineFeatureCode =m_PolygonNode.FeatureCode;
                string strRepresentation = m_PolygonNode.Representation;


                ///遍历所有外环及关联的内环
                while (pCurrentExteriorRing != null)
                {
                    ///设置当前外环数据
                    //List<LineNodeEx> pListExLine = GetLineByRing(pCurrentExteriorRing, strLineFeatureCode,strRepresentation, m_PolygonNode.EntityID);
                    List<LineNodeEx> pListExLine = GetLineNodeExsByRing(pCurrentExteriorRing, strLineFeatureCode, strRepresentation, m_PolygonNode.EntityID);
                    if (pListExLine != null)
                    {
                        pListNodeEx.AddRange(pListExLine);

                        ///不相连的环添加标识码为0的空数据
                        LineNodeEx pOutTempLineNodeEx = new LineNodeEx();
                        pOutTempLineNodeEx.EntityID = 0;
                        pOutTempLineNodeEx.PolygonID = m_PolygonNode.EntityID;
                        pListNodeEx.Add(pOutTempLineNodeEx);

                        ///获取当前外环的关联内环
                        IGeometryBag pInteriorRings = pGeoPolygon.get_InteriorRingBag(pCurrentExteriorRing);
                        IEnumGeometry pInteriorRingsEnum = pInteriorRings as IEnumGeometry;
                        pInteriorRingsEnum.Reset();
                        IRing pCurrentInteriorRing = pInteriorRingsEnum.Next() as IRing;
                        ////遍历内环
                        while (pCurrentInteriorRing != null)
                        {

                            List<LineNodeEx> pListInLine = GetLineByRing(pCurrentInteriorRing, strLineFeatureCode, strRepresentation, m_PolygonNode.EntityID);
                            if (pListInLine != null)
                            {
                                pListNodeEx.AddRange(pListInLine);

                                ///不相连的环添加标识码为0的空数据
                                LineNodeEx pInTempLineNodeEx = new LineNodeEx();
                                pInTempLineNodeEx.EntityID = 0;
                                pInTempLineNodeEx.PolygonID = m_PolygonNode.EntityID;
                                pListNodeEx.Add(pInTempLineNodeEx);

                            }

                            //处理下一个内环
                            pCurrentInteriorRing = pInteriorRingsEnum.Next() as IRing;
                        }
                    }
                    ///处理下一个外环
                    pCurrentExteriorRing = pExteriorRingsEnum.Next() as IRing;
                }

                ///删除集合中最后一位补零线段
                if (pListNodeEx.Count>0&& pListNodeEx[pListNodeEx.Count - 1].EntityID == 0)
                    pListNodeEx.RemoveAt(pListNodeEx.Count - 1);
                m_PolygonNode.LineNodes = pListNodeEx;
                //获取标志点
                IArea pArea = pFeature.Shape as IArea;
                if (pArea != null)
                    m_PolygonNode.LablePointInfoNode = new PointInfoNode(pArea.LabelPoint.X, pArea.LabelPoint.Y);
                return m_PolygonNode;
            }
            catch (Exception ex)
            {
                LogAPI.WriteErrorLog(ex);
                return null;
            }
        }
        
 

    }//end PolygonEntity

}//end namespace ESRIData