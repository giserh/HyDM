///////////////////////////////////////////////////////////
//  LineNode.cs
//  Implementation of the Class LineNode
//  Generated by Enterprise Architect
//  Created on:      08-四月-2011 13:45:31
//  Original author: Administrator
///////////////////////////////////////////////////////////




using DIST.DGP.DataExchange.VCT.FileData;
using System.Collections.Generic;
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace DIST.DGP.DataExchange.VCT.FileData {
	/// <summary>
	/// 线实体节点类
	/// </summary>
    [Serializable]
	public class LineNode : EntityNode,IComparable
    {

		/// <summary>
        /// 线的特征类型。其中：1表示直接坐标线，100表示间接坐标线。土地利用规划线状数据采用直接坐标线描述。
		/// </summary>
        public int LineType=1;
        //{
        //    get
        //    {
        //        return m_nLineType;
        //    }
        //    set
        //    {
        //        m_nLineType = value;
        //    }
        //}
        //private int m_nLineType = 1;

        ///// <summary>
        ///// VCT文件写入对象  add by 曾平 解决大数据量写入内存溢出的问题
        ///// </summary>
        //private StreamWriter m_streamWriter;
        ///// <summary>
        ///// VCT文件写入对象
        ///// </summary>
        //public StreamWriter StreamWriter
        //{
        //    set
        //    {
        //        m_streamWriter = value;
        //    }
        //}

        /// <summary>
        /// 线段集合
        /// </summary>
        public SegmentNodes SegmentNodes;
        //{
        //    get
        //    {
        //        return m_arrSegmentNode;
        //    }
        //    set
        //    {
        //        m_arrSegmentNode = value;
        //    }
        //}
        //private SegmentNodes m_arrSegmentNode;

        //public LineNode(){

        //}

        //~LineNode(){

        //}

        //public override void Dispose(){

        //}

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            string strNode = base.ToString();
            strNode += "\r\n" + this.LineType.ToString();
            strNode += "\r\n" + this.SegmentNodes.Count.ToString();
            for (int i = 0; i < this.SegmentNodes.Count; i++)
            {
                //m_arrSegmentNode[i].StreamWriter = m_streamWriter;
                strNode += "\r\n" + this.SegmentNodes[i].ToString();
                //if (m_streamWriter != null && i % 1000 == 0)
                //{
                //    // add by 曾平 解决大数据量写入内存溢出的问题
                //    m_streamWriter.WriteLine(strNode);
                //    m_streamWriter.Flush();
                //    strNode = "";
                //}
            }

            strNode += "\r\n0";
            return strNode;
        }

        /// <summary>
        /// 操作符“>”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator >(LineNode xLineNode, LineNode yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                return false;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return true;
            }
            if (xLineNode.SegmentNodes == yLineNode.SegmentNodes)
            {
                return xLineNode.EntityID > yLineNode.EntityID ? true : false;
            }
            return xLineNode.SegmentNodes > yLineNode.SegmentNodes ? true : false;
        }

        /// <summary>
        /// 操作符“==”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator ==(LineNode xLineNode, LineNode yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                if (object.Equals(yLineNode, null))
                    return true;
                else
                    return false;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return false;
            }
            return xLineNode.SegmentNodes == yLineNode.SegmentNodes ? true : false;
        }

        /// <summary>
        /// 操作符“!=”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator !=(LineNode xLineNode, LineNode yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                if (object.Equals(yLineNode, null))
                    return false;
                else
                    return true;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return true;

            }
            return xLineNode.SegmentNodes != yLineNode.SegmentNodes ? true : false;
        }

        /// <summary>
        /// 操作符“<”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator <(LineNode xLineNode, LineNode yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                return true;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return false;
            }
            if (xLineNode.SegmentNodes == yLineNode.SegmentNodes)
            {
                return xLineNode.EntityID < yLineNode.EntityID ? true : false;
            }
            return xLineNode.SegmentNodes < yLineNode.SegmentNodes ? true : false;
        }

        /// <summary>
        /// 重写方法，Equals
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            return this == obj as LineNode ? true : false;
        }

        /// <summary>
        /// 重写方法，GetHashCode
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public int CompareTo(object obj)
        {
            LineNode objLineNode = obj as LineNode;
            if (this > objLineNode)
                return 1;
            
            return -1;
        }

	}//end LineNode


    public class LineNodeSimple : EntityNode, IComparable
    {

        /// <summary>
        /// 线的特征类型。其中：1表示直接坐标线，100表示间接坐标线。土地利用规划线状数据采用直接坐标线描述。
        /// </summary>
        public int LineType = 1;


        /// <summary>
        /// 线段集合
        /// </summary>
        public double X1 = 0.0;
        public double Y1 = 0.0;
        public double X2 = 0.0;
        public double Y2 = 0.0;

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            string strNode = base.ToString();
            strNode += "\r\n" + this.LineType.ToString();
            strNode += "\r\n1";

            strNode += "\r\n11";
            strNode += "\r\n2";
            strNode += "\r\n" + this.X1.ToString() + HeadNode.Separator.ToString() + this.Y1.ToString();
            strNode += "\r\n" + this.X2.ToString() + HeadNode.Separator.ToString() + this.Y2.ToString();

            strNode += "\r\n0";
            return strNode;
        }

        /// <summary>
        /// 操作符“>”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator >(LineNodeSimple xLineNode, LineNodeSimple yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                return false;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return true;
            }
            if (xLineNode.X1 - yLineNode.X1 < 0.000001 && xLineNode.X1 - yLineNode.X1 > -0.000001)
            {
                if (xLineNode.Y1 - yLineNode.Y1 < 0.000001 && xLineNode.Y1 - yLineNode.Y1 > -0.000001)
                {
                    if (xLineNode.X2 - yLineNode.X2 < 0.000001 && xLineNode.X2 - yLineNode.X2 > -0.000001)
                    {
                        if (xLineNode.Y2 - yLineNode.Y2 < 0.000001 && xLineNode.Y2 - yLineNode.Y2 > -0.000001)
                        {
                            return xLineNode.EntityID > yLineNode.EntityID ? true : false;
                        }
                        return xLineNode.Y2 > yLineNode.Y2 ? true : false;
                    }
                    return xLineNode.X2 > yLineNode.X2 ? true : false;
                }
                return xLineNode.Y1 > yLineNode.Y1 ? true : false;
            }
            return xLineNode.X1 > yLineNode.X1 ? true : false;
        }

        /// <summary>
        /// 操作符“==”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator ==(LineNodeSimple xLineNode, LineNodeSimple yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                if (object.Equals(yLineNode, null))
                    return true;
                else
                    return false;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return false;
            }
            if (xLineNode.X1 - yLineNode.X1 < 0.000001 && xLineNode.X1 - yLineNode.X1 > -0.000001)
            {
                if (xLineNode.Y1 - yLineNode.Y1 < 0.000001 && xLineNode.Y1 - yLineNode.Y1 > -0.000001)
                {
                    if (xLineNode.X2 - yLineNode.X2 < 0.000001 && xLineNode.X2 - yLineNode.X2 > -0.000001)
                    {
                        if (xLineNode.Y2 - yLineNode.Y2 < 0.000001 && xLineNode.Y2 - yLineNode.Y2 > -0.000001)
                        {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /// <summary>
        /// 操作符“!=”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator !=(LineNodeSimple xLineNode, LineNodeSimple yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                if (object.Equals(yLineNode, null))
                    return false;
                else
                    return true;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return true;

            }
            if (xLineNode.X1 - yLineNode.X1 < 0.000001 && xLineNode.X1 - yLineNode.X1 > -0.000001)
            {
                if (xLineNode.Y1 - yLineNode.Y1 < 0.000001 && xLineNode.Y1 - yLineNode.Y1 > -0.000001)
                {
                    if (xLineNode.X2 - yLineNode.X2 < 0.000001 && xLineNode.X2 - yLineNode.X2 > -0.000001)
                    {
                        if (xLineNode.Y2 - yLineNode.Y2 < 0.000001 && xLineNode.Y2 - yLineNode.Y2 > -0.000001)
                        {
                            return false;
                        }
                    }
                }
            }
            return true;
        }

        /// <summary>
        /// 操作符“<”
        /// </summary>
        /// <param name="xLineNode">线实体节点</param>
        /// <param name="yLineNode">线实体节点</param>
        public static bool operator <(LineNodeSimple xLineNode, LineNodeSimple yLineNode)
        {
            if (object.Equals(xLineNode, null))
            {
                return true;
            }
            else
            {
                if (object.Equals(yLineNode, null))
                    return false;
            }
            if (xLineNode.X1 - yLineNode.X1 < 0.000001 && xLineNode.X1 - yLineNode.X1 > -0.000001)
            {
                if (xLineNode.Y1 - yLineNode.Y1 < 0.000001 && xLineNode.Y1 - yLineNode.Y1 > -0.000001)
                {
                    if (xLineNode.X2 - yLineNode.X2 < 0.000001 && xLineNode.X2 - yLineNode.X2 > -0.000001)
                    {
                        if (xLineNode.Y2 - yLineNode.Y2 < 0.000001 && xLineNode.Y2 - yLineNode.Y2 > -0.000001)
                        {
                            return xLineNode.EntityID < yLineNode.EntityID ? true : false;
                        }
                        return xLineNode.Y2 < yLineNode.Y2 ? true : false;
                    }
                    return xLineNode.X2 < yLineNode.X2 ? true : false;
                }
                return xLineNode.Y1 < yLineNode.Y1 ? true : false;
            }
            return xLineNode.X1 < yLineNode.X1 ? true : false;

        }

        /// <summary>
        /// 重写方法，Equals
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            return this == obj as LineNodeSimple ? true : false;
        }

        /// <summary>
        /// 重写方法，GetHashCode
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        public int CompareTo(object obj)
        {
            LineNodeSimple objLineNode = obj as LineNodeSimple;
            if (this > objLineNode)
                return 1;

            return -1;
        }

    }//end LineNode

    /// <summary>
	/// 线实体节点类。面的引用线实体节点
	/// </summary>
    [Serializable]
    public class LineNodeEx : LineNode//, ICloneable
    {
        /// <summary>
        /// 构造函数
        /// </summary>
        public LineNodeEx()
        {
            this.IsReverse = false;
            this.PolygonID = -1;
            //this.m_nLineIndex = -1;
        }

        /// <summary>
        /// 是否反向
        /// </summary>
        public bool IsReverse=false;
        //{
        //    get
        //    {
        //        return m_bReverse;
        //    }
        //    set
        //    {
        //        m_bReverse = value;
        //    }
        //}
        //private bool m_bReverse = false;

        #region 拓扑关系
        /// <summary>
        /// 所属面的标识码
        /// </summary>
        public int PolygonID = -1;
        //{
        //    get
        //    {
        //        return m_nPolygonID;
        //    }
        //    set
        //    {
        //        m_nPolygonID = value;
        //    }
        //}
        //private int m_nPolygonID = -1;

        ///// <summary>
        ///// 另一个面的标识码
        ///// </summary>
        //public int OtherPolygonID = -1;
        //{
        //    get
        //    {
        //        return m_nOtherPolygonID;
        //    }
        //    set
        //    {
        //        m_nOtherPolygonID = value;
        //    }
        //}
        //private int m_nOtherPolygonID = -1;

        /// <summary>
        /// 在面的线集合中的索引
        /// </summary>
        public int LineIndex=-1;
        //{
        //    get
        //    {
        //        return m_nLineIndex;
        //    }
        //    set
        //    {
        //        m_nLineIndex = value;
        //    }
        //}
        //private int m_nLineIndex = -1;

        ///// <summary>
        ///// 在另一个面的线集合中的索引
        ///// </summary>
        //public int OtherLineIndex
        //{
        //    get
        //    {
        //        return m_nOtherLineIndex;
        //    }
        //    set
        //    {
        //        m_nOtherLineIndex = value;
        //    }
        //}
        //private int m_nOtherLineIndex = -1;

        ///// <summary>
        ///// 所属面在面集合中的索引
        ///// </summary>
        //public int PolygonIndex
        //{
        //    get
        //    {
        //        return m_nPolygonIndex;
        //    }
        //    set
        //    {
        //        m_nPolygonIndex = value;
        //    }
        //}
        //private int m_nPolygonIndex = -1;

        ///// <summary>
        ///// 所属另一个面的面集合中的索引
        ///// </summary>
        //public int OtherPolygonIndex
        //{
        //    get
        //    {
        //        return m_nOtherPolygonIndex;
        //    }
        //    set
        //    {
        //        m_nOtherPolygonIndex = value;
        //    }
        //}
        //private int m_nOtherPolygonIndex = -1;

        /// <summary>
        /// 原始对象
        /// </summary>
        //public LineNodeEx OtherPolygonLineNode=null;
        public int OrtherIndexID = -1;
        //{
        //    get
        //    {
        //        return m_OtherPolygonNode;
        //    }
        //    set
        //    {
        //        m_OtherPolygonNode = value;
        //    }

        //}
        //private LineNodeEx m_OtherPolygonNode = null;

        /// <summary>
        /// 是否是引用线
        /// </summary>
        public bool IsFromLine=false;
        //{
        //    get
        //    {
        //        return m_bFromLine;
        //    }
        //    set
        //    {
        //        m_bFromLine = value;
        //    }
        //}
        //private bool m_bFromLine = false;


        #endregion

        /// <summary>
        /// 反向
        /// </summary>
        public void Reverse()
        {
            this.IsReverse = !(this.IsReverse);

            this.SegmentNodes.Reverse();
        }

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            string strNode = this.EntityID.ToString();
            if (this.IsReverse == true)
                strNode = "-" + strNode;
            return strNode;
        }

        /// <summary>
        /// 输出VCT节点（父节点，构面线）
        /// </summary>
        public string ToLineString()
        {
            return base.ToString();
        }

        /// <summary>
        /// 原始对象
        /// </summary>
        //public LineNodeEx InitiallyLineNode=null;
        //{
        //    get
        //    {
        //        return m_InitiallyLineNode;
        //    }
        //    set
        //    {
        //        m_InitiallyLineNode = value;
        //    }

        //}
        //private LineNodeEx m_InitiallyLineNode = null;

    //    public Object Clone()
    //    {
    //        //m_InitiallyLineNode = this;
    //        /*
    //        MemoryStream stream = new MemoryStream();
    //        BinaryFormatter formatter = new BinaryFormatter();
    //        formatter.Serialize(stream, this);
    //        stream.Position = 0;

    //        try
    //        {

    //            LineNodeEx lineNodeEx = formatter.Deserialize(stream) as LineNodeEx;

    //            lineNodeEx.InitiallyLineNode = this;
    //            return lineNodeEx;
    //        }
    //        catch (Exception ex)
    //        {
    //            LogAPI.WriteErrorLog(ex);
    //        }
    //         * */
    //        try
    //        {
    //            LineNodeEx lineNodeEx = new LineNodeEx();
    //            lineNodeEx.IsReverse = this.IsReverse;
    //            lineNodeEx.PolygonID = this.PolygonID;
    //            lineNodeEx.LineIndex = this.LineIndex;
    //            lineNodeEx.IsFromLine = this.IsFromLine;

    //            lineNodeEx.LineType = this.LineType;
    //            lineNodeEx.SegmentNodes = new SegmentNodes();
    //            for (int i = 0; i < this.SegmentNodes.Count; i++)
    //            {
    //                lineNodeEx.SegmentNodes.Add(this.SegmentNodes[i]);
    //                //BrokenLineNode brokenLineNode1 = this.SegmentNodes[i] as BrokenLineNode;
    //                //if (brokenLineNode1 != null)
    //                //{
    //                //    BrokenLineNode brokenLineNode2 = new BrokenLineNode();
    //                //    brokenLineNode2.PointInfoNodes = new PointInfoNodes();
    //                //    for (int j = 0; j < brokenLineNode1.PointInfoNodes.Count; j++)
    //                //    {
    //                //        PointInfoNode pointInfoNode = new PointInfoNode();
    //                //        pointInfoNode.X = brokenLineNode1.PointInfoNodes[j].X;
    //                //        pointInfoNode.Y = brokenLineNode1.PointInfoNodes[j].Y;
    //                //        brokenLineNode2.PointInfoNodes.Add(pointInfoNode);
    //                //    }
    //                //    lineNodeEx.SegmentNodes.Add(brokenLineNode2);
    //                //}
    //            }

    //            lineNodeEx.EntityID = this.EntityID;
    //            lineNodeEx.FeatureCode = this.FeatureCode;
    //            lineNodeEx.Representation = this.Representation;

    //            lineNodeEx.InitiallyLineNode = this;
    //            return lineNodeEx;
    //        }
    //        catch (Exception ex)
    //        {
    //            LogAPI.WriteErrorLog(ex);
    //        }
    //        return null;
    //    }

}//end LineNodeEx

    public class LineNodeSimpleEx : LineNodeSimple
    {
        /// <summary>
        /// 构造函数
        /// </summary>
        public LineNodeSimpleEx()
        {
            this.IsReverse = false;
            this.PolygonID = -1;
        }

        /// <summary>
        /// 是否反向
        /// </summary>
        public bool IsReverse = false;

        #region 拓扑关系
        /// <summary>
        /// 所属面的标识码
        /// </summary>
        public int PolygonID = -1;

        /// <summary>
        /// 在面的线集合中的索引
        /// </summary>
        public int LineIndex = -1;

        /// <summary>
        /// 匹配到的另一实体索引
        /// </summary>
        public int OrtherIndexID = -1;
 
        /// <summary>
        /// 是否是引用线
        /// </summary>
        public bool IsFromLine = false;
        
        #endregion

        /// <summary>
        /// 反向
        /// </summary>
        public void Reverse()
        {
            this.IsReverse = !(this.IsReverse);

            double dX = this.X1;
            double dY = this.Y1;

            this.X1 = this.X2;
            this.Y1 = this.Y2;
            this.X2 = dX;
            this.Y2 = dY;
        }

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            string strNode = this.EntityID.ToString();
            if (this.IsReverse == true)
                strNode = "-" + strNode;
            return strNode;
        }

        /// <summary>
        /// 输出VCT节点（父节点，构面线）
        /// </summary>
        public string ToLineString()
        {
            return base.ToString();
        }

    }//end LineNodeEx

    public class LineNodeExComparer : IComparer<LineNodeEx>
    {
        public int Compare(LineNodeEx xLineNodeEx, LineNodeEx yLineNodeEx)
        {
            if (xLineNodeEx.EntityID == yLineNodeEx.EntityID)
            {
                if (xLineNodeEx.LineIndex == yLineNodeEx.LineIndex)
                    return 0;
                else
                    return xLineNodeEx.LineIndex - yLineNodeEx.LineIndex;
            }
            else
            {
                return xLineNodeEx.EntityID - yLineNodeEx.EntityID;
            }
        }
    }

}//end namespace FileData