///////////////////////////////////////////////////////////
//  BrokenLineNode.cs
//  Implementation of the Class BrokenLineNode
//  Generated by Enterprise Architect
//  Created on:      08-四月-2011 13:45:30
//  Original author: Administrator
///////////////////////////////////////////////////////////




using DIST.DGP.DataExchange.VCT.FileData;
using System.Collections.Generic;
using System;
namespace DIST.DGP.DataExchange.VCT.FileData {
	/// <summary>
	/// VCT折线节点类
	/// </summary>
    [Serializable]
	public class BrokenLineNode : SegmentNode {

        /// <summary>
        /// 点坐标信息节点集合
        /// </summary>
        public PointInfoNodes PointInfoNodes;
        //{
        //    get
        //    {
        //        return m_arrPointInfoNode;
        //    }
        //    set
        //    {
        //        m_arrPointInfoNode = value;
        //    }
        //}
        //private PointInfoNodes m_arrPointInfoNode;


        public BrokenLineNode()
            : base(11)
        {

		}

        //~BrokenLineNode(){

        //}

        //public override void Dispose(){

        //}

        /// <summary>
        /// 操作符“>”
        /// </summary>
        /// <param name="xBrokenLineNode">折线节点</param>
        /// <param name="yBrokenLineNode">折线节点</param>
        public static bool operator >(BrokenLineNode xBrokenLineNode, BrokenLineNode yBrokenLineNode)
        {
            if (object.Equals(xBrokenLineNode, null))
            {
                return false;
            }
            else
            {
                if (object.Equals(yBrokenLineNode, null))
                    return true;
            }

            return xBrokenLineNode.PointInfoNodes > yBrokenLineNode.PointInfoNodes ? true : false;
        }

        /// <summary>
        /// 操作符“==”
        /// </summary>
        /// <param name="xBrokenLineNode">折线节点</param>
        /// <param name="yBrokenLineNode">折线节点</param>
        public static bool operator ==(BrokenLineNode xBrokenLineNode, BrokenLineNode yBrokenLineNode)
        {
            if (object.Equals(xBrokenLineNode, null))
            {
                if (object.Equals(yBrokenLineNode, null))
                    return true;
                else
                    return false;
            }
            else
            {
                if (object.Equals(yBrokenLineNode, null))
                    return false;
            }
            return xBrokenLineNode.PointInfoNodes == yBrokenLineNode.PointInfoNodes ? true : false;
        }

        /// <summary>
        /// 操作符“!=”
        /// </summary>
        /// <param name="xBrokenLineNode">折线节点</param>
        /// <param name="yBrokenLineNode">折线节点</param>
        public static bool operator !=(BrokenLineNode xBrokenLineNode, BrokenLineNode yBrokenLineNode)
        {
            if (object.Equals(xBrokenLineNode, null))
            {
                if (object.Equals(yBrokenLineNode, null))
                    return false;
                else
                    return true;
            }
            else
            {
                if (object.Equals(yBrokenLineNode, null))
                    return true;

            }
            return xBrokenLineNode.PointInfoNodes != yBrokenLineNode.PointInfoNodes ? true : false;
        }

        /// <summary>
        /// 操作符“<”
        /// </summary>
        /// <param name="xBrokenLineNode">折线节点</param>
        /// <param name="yBrokenLineNode">折线节点</param>
        public static bool operator <(BrokenLineNode xBrokenLineNode, BrokenLineNode yBrokenLineNode)
        {
            if (object.Equals(xBrokenLineNode, null))
            {
                return true;
            }
            else
            {
                if (object.Equals(yBrokenLineNode, null))
                    return false;
            } 
            return xBrokenLineNode.PointInfoNodes < yBrokenLineNode.PointInfoNodes ? true : false;
        }

        /// <summary>
        /// 重写方法，Equals
        /// </summary>
        /// <param name="obj"></param>
        /// <returns></returns>
        public override bool Equals(object obj)
        {
            if (obj == null || GetType() != obj.GetType()) return false;

            return this == obj as BrokenLineNode ? true : false;
        }

        /// <summary>
        /// 重写方法，GetHashCode
        /// </summary>
        /// <returns></returns>
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        /// <summary>
        /// 反向
        /// </summary>
        public override void Reverse()
        {
            this.PointInfoNodes.Reverse();
        }

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            string strNode = base.ToString();
            strNode += "\r\n" + this.PointInfoNodes.Count.ToString();
            for (int i = 0; i < this.PointInfoNodes.Count; i++)
            {
                strNode += "\r\n" + this.PointInfoNodes[i].ToString();
                //if (base.m_streamWriter != null && i % 1000 == 0)
                //{
                //    // add by 曾平 解决大数据量写入内存溢出的问题
                //    base.m_streamWriter.WriteLine(strNode);
                //    base.m_streamWriter.Flush();
                //    strNode = "";
                //}
            }
            return strNode;
        }
	}//end BrokenLineNode

}//end namespace FileData