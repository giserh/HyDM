///////////////////////////////////////////////////////////
//  PolygonNode.cs
//  Implementation of the Class PolygonNode
//  Generated by Enterprise Architect
//  Created on:      08-四月-2011 13:45:32
//  Original author: Administrator
///////////////////////////////////////////////////////////




using DIST.DGP.DataExchange.VCT.FileData;
using System.Collections.Generic;
namespace DIST.DGP.DataExchange.VCT.FileData {
	/// <summary>
	/// VCT面实体节点类
	/// </summary>
	public class PolygonNode : EntityNode {

		/// <summary>
		/// 标识点坐标
		/// </summary>
        public PointInfoNode LablePointInfoNode
        {
            get
            {
                return m_lablePointInfoNode;
            }
            set
            {
                m_lablePointInfoNode = value;
            }
        }
		private PointInfoNode m_lablePointInfoNode;

		/// <summary>
        /// 面的特征类型。其中：1表示由直接坐标表示的面对象，100表示由间接坐标表示的面对象。土地利用规划面状数据采用间接坐标交换。
		/// </summary>
        public int PolygonType
        {
            get
            {
                return m_nPolygonType;
            }
            set
            {
                m_nPolygonType = value;
            }
        }
        private int m_nPolygonType = 100;

        /// <summary>
        /// 间接坐标面的构成类型。21表示引用线对象构成的面，22表示引用面对象构成的面。
        /// </summary>
        public int ComposeType
        {
            get
            {
                return m_nComposeType;
            }
        }
        private int m_nComposeType = 21;

        /// <summary>
        /// 线对象集合
        /// </summary>
        public List<LineNodeEx> LineNodes
        {
            get
            {
                return m_arrLineNode;
            }
            set
            {
                m_arrLineNode = value;
            }
        }
        private List<LineNodeEx> m_arrLineNode;

		public PolygonNode(){

		}

        //~PolygonNode(){

        //}

        //public override void Dispose(){

        //}

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            //过滤相同的线节点
            List<LineNodeEx> arrLineNode = new List<LineNodeEx>();
            for (int i = 0; i < m_arrLineNode.Count; i++)
            {
                if (i == 0 || (i > 0 && m_arrLineNode[i].EntityID != m_arrLineNode[i - 1].EntityID))
                {
                    arrLineNode.Add(m_arrLineNode[i]);
                }
            }

            //输出VCT节点
            string strNode = base.ToString();
            strNode += "\r\n" + this.m_nPolygonType.ToString();
            strNode += "\r\n" + this.m_lablePointInfoNode.ToString();
            strNode += "\r\n" + this.m_nComposeType.ToString();
            strNode += "\r\n" + arrLineNode.Count.ToString();


            int k = 0;
            for (int i = 0; i < 0.125 * arrLineNode.Count; i++)//行数
            {
                strNode += "\r\n";
                for (int j = 0; k < arrLineNode.Count && j < 8; j++)
                {
                    if (j > 0)
                        strNode += HeadNode.Separator.ToString();
                    strNode += arrLineNode[k++].ToString();
                }
            }

            strNode += "\r\n0";

            return strNode;
        }

        ///// <summary>
        ///// 更新线节点在面的线节点集合中的索引
        ///// </summary>
        //public void MergeLineEntityID()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //    }
        //}



        ///// <summary>
        ///// 合并线节点标识码
        ///// </summary>
        //public void MergeLineEntityID()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //        //合并线
        //        LineNodeEx lineNodeBegin = null;//环的开始线节点
        //        int nIndexBegin = -1;
        //        bool bExistUp = false;
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            //m_arrLineNode[i].LineIndex = i;
        //            if (lineNodeBegin == null)
        //            {
        //                lineNodeBegin = m_arrLineNode[i];
        //                nIndexBegin = i;
        //            }

        //            if (bExistUp == true)
        //            {
        //                if (m_arrLineNode[i].EntityID == 0)//合并处理必须在同一个环内处理
        //                {
        //                    if (lineNodeBegin != null && i > 0)
        //                    {
        //                        bool bNeedFind = true;
        //                        int k = i;
        //                        while (bNeedFind == true)
        //                        {
        //                            if (k <= nIndexBegin)
        //                                break;

        //                            //不仅仅是最后一个
        //                            if ((lineNodeBegin.OtherPolygonLineNode != null && m_arrLineNode[k - 1].OtherPolygonLineNode != null && lineNodeBegin.OtherPolygonLineNode.PolygonID == m_arrLineNode[k - 1].OtherPolygonLineNode.PolygonID)
        //                                || (lineNodeBegin.OtherPolygonLineNode == null && m_arrLineNode[k - 1].OtherPolygonLineNode == null && lineNodeBegin.IsFromLine == false && m_arrLineNode[k - 1].IsFromLine==false))
        //                            {
        //                                //合并线
        //                                m_arrLineNode[k - 1].EntityID = lineNodeBegin.EntityID;

        //                                if (m_arrLineNode[k - 1].IsReverse != lineNodeBegin.IsReverse)
        //                                {
        //                                    //若方向不一致
        //                                    m_arrLineNode[k - 1].Reverse();
        //                                    //在另一个面中的对象也反向
        //                                    if (m_arrLineNode[k - 1].OtherPolygonLineNode != null)
        //                                        m_arrLineNode[k - 1].OtherPolygonLineNode.Reverse();
        //                                }

        //                                k--;
        //                            }
        //                            else
        //                                bNeedFind = false;
        //                        }
        //                        lineNodeBegin = null;
        //                    }

        //                    bExistUp = false;
        //                }
        //                else if (m_arrLineNode[i].IsFromLine == true)//当前线节点是引用线
        //                {
        //                    bExistUp = false;
        //                }
        //                else
        //                {
        //                    //线所属的面必须一致
        //                    if ((m_arrLineNode[i].OtherPolygonLineNode != null && m_arrLineNode[i - 1].OtherPolygonLineNode != null && m_arrLineNode[i].OtherPolygonLineNode.PolygonID == m_arrLineNode[i - 1].OtherPolygonLineNode.PolygonID)
        //                        || (m_arrLineNode[i].OtherPolygonLineNode == null && m_arrLineNode[i - 1].OtherPolygonLineNode == null && m_arrLineNode[i].IsFromLine == false && m_arrLineNode[i - 1].IsFromLine == false))
        //                    {
        //                        //合并线
        //                        m_arrLineNode[i].EntityID = m_arrLineNode[i - 1].EntityID;

        //                        if (m_arrLineNode[i].IsReverse != m_arrLineNode[i - 1].IsReverse)
        //                        {
        //                            //若方向不一致
        //                            m_arrLineNode[i].Reverse();
        //                            //在另一个面中的对象也反向
        //                            if (m_arrLineNode[i].OtherPolygonLineNode != null)
        //                                m_arrLineNode[i].OtherPolygonLineNode.Reverse();
        //                        }
        //                    }

        //                }
        //            }
        //            else
        //            {
        //                bExistUp = true;
        //            }
        //        }
        //        if (lineNodeBegin != null && m_arrLineNode.Count > 1)
        //        {
        //            bool bNeedFind = true;
        //            int k = m_arrLineNode.Count;
        //            while (bNeedFind == true)
        //            {
        //                if (k <= nIndexBegin)
        //                    break;

        //                //不仅仅是最后一个
        //                if ((lineNodeBegin.OtherPolygonLineNode != null && m_arrLineNode[k - 1].OtherPolygonLineNode != null && lineNodeBegin.OtherPolygonLineNode.PolygonID == m_arrLineNode[k - 1].OtherPolygonLineNode.PolygonID)
        //                    || (lineNodeBegin.OtherPolygonLineNode == null && m_arrLineNode[k - 1].OtherPolygonLineNode == null && lineNodeBegin.IsFromLine == false && m_arrLineNode[k - 1].IsFromLine == false))
        //                {
        //                    m_arrLineNode[k - 1].EntityID = lineNodeBegin.EntityID;

        //                    if (m_arrLineNode[k - 1].IsReverse != lineNodeBegin.IsReverse)
        //                    {
        //                        //若方向不一致
        //                        m_arrLineNode[k - 1].Reverse();
        //                        //在另一个面中的对象也反向
        //                        if (m_arrLineNode[k - 1].OtherPolygonLineNode != null)
        //                            m_arrLineNode[k - 1].OtherPolygonLineNode.Reverse();

        //                    }
        //                    k--;
        //                }
        //                else
        //                    bNeedFind = false;
        //            }
        //        }

        //    }
        //}

        ///// <summary>
        ///// 处理环内同一边界线分布在环的首尾的情况
        ///// </summary>
        //public void UpdateRing(/*ref List<FileData.PolygonNode> arrPolygonNode*/)
        //{
        //    LineNodeEx lineNodeBegin = null;//环的开始线节点
        //    int nIndexBegin = -1;

        //    bool bNeedMove = false;//是否需要处理
        //    int nIndexEnd = -1;    //环的结束索引（该索引以后的节点都要移到环的开始位置
        //    for (int i = 0; i < m_arrLineNode.Count; i++)
        //    {
        //        if (lineNodeBegin == null)
        //        {
        //            lineNodeBegin = m_arrLineNode[i];
        //            nIndexBegin = i;
        //            bNeedMove = false;
        //        }
        //        if (i > 0)
        //        {
        //            if (m_arrLineNode[i].EntityID == 0)
        //            {
        //                if (bNeedMove == true)
        //                {
        //                    ////在另一个面中的对象也要处理
        //                    //List<LineNodeEx> arrLineNode = null;
        //                    //int nIndexOtherBegin = -1;
        //                    //int nIndexOtherEnd = -1;
        //                    //if (lineNodeBegin.OtherPolygonLineNode != null)
        //                    //{
        //                    //    arrLineNode = arrPolygonNode[lineNodeBegin.OtherPolygonLineNode.PolygonIndex].LineNodes;
        //                    //    nIndexOtherBegin = m_arrLineNode[i - 1].OtherPolygonLineNode.LineIndex;
        //                    //    nIndexOtherEnd = m_arrLineNode[nIndexBegin].OtherPolygonLineNode.LineIndex;
        //                    //}

        //                    for (int j = i - 1; j > nIndexEnd; nIndexEnd++)
        //                    {
        //                        ////前面往后移
        //                        //if (arrLineNode != null)
        //                        //{
        //                        //    arrLineNode.Insert(nIndexOtherEnd + 1, m_arrLineNode[j].OtherPolygonLineNode);
        //                        //    arrLineNode.RemoveAt(nIndexOtherBegin);
        //                        //}

        //                        //后面往前移
        //                        m_arrLineNode.Insert(nIndexBegin, m_arrLineNode[j]);
        //                        m_arrLineNode.RemoveAt(j + 1);
        //                    }


        //                    //if (arrLineNode != null)
        //                    //{
        //                    //    //更新索引
        //                    //    for (int k = 0; k < arrLineNode.Count; k++)
        //                    //    {
        //                    //        arrLineNode[k].LineIndex = k;
        //                    //    }
        //                    //}

        //                }
        //                lineNodeBegin = null;
        //            }
        //            else if (m_arrLineNode[i].EntityID != lineNodeBegin.EntityID)
        //            {
        //                bNeedMove = true;
        //                nIndexEnd = i;
        //            }
        //        }
        //    }
        //    if (bNeedMove == true)
        //    {
        //        ////在另一个面中的对象也要处理
        //        //List<LineNodeEx> arrLineNode = null;
        //        //int nIndexOtherBegin = -1;
        //        //int nIndexOtherEnd = -1;
        //        //if (lineNodeBegin.OtherPolygonLineNode != null)
        //        //{
        //        //    arrLineNode = arrPolygonNode[lineNodeBegin.OtherPolygonLineNode.PolygonIndex].LineNodes;
        //        //    nIndexOtherBegin = m_arrLineNode[m_arrLineNode.Count - 1].OtherPolygonLineNode.LineIndex;
        //        //    nIndexOtherEnd = m_arrLineNode[nIndexBegin].OtherPolygonLineNode.LineIndex;
        //        //}

        //        for (int j = m_arrLineNode.Count - 1; j > nIndexEnd; nIndexEnd++)
        //        {

        //            ////前面往后移
        //            //if (arrLineNode != null)
        //            //{
        //            //    arrLineNode.Insert(nIndexOtherEnd + 1, m_arrLineNode[j].OtherPolygonLineNode);
        //            //    arrLineNode.RemoveAt(nIndexOtherBegin);
        //            //}

        //            //后面往前移
        //            m_arrLineNode.Insert(nIndexBegin, m_arrLineNode[j]);
        //            m_arrLineNode.RemoveAt(j + 1);
        //        }

        //        //if (arrLineNode != null)
        //        //{
        //        //    //更新索引
        //        //    for (int k = 0; k < arrLineNode.Count; k++)
        //        //    {
        //        //        arrLineNode[k].LineIndex = k;
        //        //    }
        //        //}

        //    }
        //    //更新线节点的索引
        //    for (int i = 0; i < m_arrLineNode.Count; i++)
        //    {
        //        m_arrLineNode[i].LineIndex = i;
        //    }
        //}

        ///// <summary>
        ///// 处理自闭合线问题（在不同面中的顺序不一致）
        ///// </summary>
        //public void UpdateClosedLineNode()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //        bool bNeed = true;//是否需要处理（方向未反向，标识码一致且同属于另一个面）
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            if (m_arrLineNode[i].IsReverse == true)
        //            {
        //                bNeed = false;
        //            }
        //            else
        //            {
        //                if (m_arrLineNode[i].OtherPolygonLineNode == null)
        //                {
        //                    bNeed = false;
        //                }
        //                else
        //                {
        //                    if (i > 0)
        //                    {
        //                        if (m_arrLineNode[i].EntityID != m_arrLineNode[i - 1].EntityID)
        //                            bNeed = false;
        //                    }
        //                }
        //            }

        //            if (bNeed == false)
        //                break;
        //        }

        //        if (bNeed == true)
        //        {
        //            for (int i = 0; i < m_arrLineNode.Count; i++)
        //            {
        //                m_arrLineNode[i].Reverse();
        //                m_arrLineNode[i].OtherPolygonLineNode.Reverse();
        //            }
        //        }
        //    }

        //}

        ///// <summary>
        ///// 处理线段在一个面中连续，另一个面中不连续的情况
        ///// </summary>
        //public void SplitLineNode()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //        List<int> arrAllEntityID = new List<int>();
        //        List<int> arrSplitEntityID = new List<int>();
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            if (m_arrLineNode[i].OtherPolygonLineNode != null)
        //            {
        //                if (i == 0)
        //                {
        //                    arrAllEntityID.Add(m_arrLineNode[i].OtherPolygonLineNode.EntityID);
        //                }
        //                else
        //                {
        //                    if (m_arrLineNode[i - 1].OtherPolygonLineNode==null||
        //                        m_arrLineNode[i].OtherPolygonLineNode.EntityID != m_arrLineNode[i - 1].OtherPolygonLineNode.EntityID)
        //                    {
        //                        if (arrAllEntityID.Contains(m_arrLineNode[i].OtherPolygonLineNode.EntityID) == false)
        //                        {
        //                            arrAllEntityID.Add(m_arrLineNode[i].OtherPolygonLineNode.EntityID);
        //                        }
        //                        else
        //                        {
        //                            arrSplitEntityID.Add(m_arrLineNode[i].OtherPolygonLineNode.EntityID);
        //                        }
        //                    }
        //                }
        //            }
        //        }
        //        for (int i = 0; i < arrSplitEntityID.Count; i++)
        //        {
        //            for (int j = 0; j < m_arrLineNode.Count; j++)
        //            {
        //                if (m_arrLineNode[j].OtherPolygonLineNode != null)
        //                {
        //                    if (arrSplitEntityID[i] == m_arrLineNode[j].OtherPolygonLineNode.EntityID)
        //                    {
        //                        if (m_arrLineNode[j].OtherPolygonLineNode.IsReverse == false)
        //                        {
        //                            m_arrLineNode[j].OtherPolygonLineNode.Reverse();
        //                            m_arrLineNode[j].Reverse();
        //                        }
        //                    }
        //                }
        //            }
        //        }

        //    }

        //}

        ///// <summary>
        ///// 更新已反向的线节点的标识码
        ///// </summary>
        //public void UpdateReverseLineEntityID()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            if (m_arrLineNode[i].IsReverse)
        //            {
        //                if (m_arrLineNode[i].OtherPolygonLineNode != null)
        //                {
        //                    m_arrLineNode[i].EntityID = m_arrLineNode[i].OtherPolygonLineNode.EntityID;
        //                }
        //            }
        //        }
        //    }

        //}


        ///// <summary>
        ///// 合并线节点
        ///// </summary>
        //public void MergeLineNode()
        //{
        //    if (m_arrLineNode != null)
        //    {
        //        //处理引用线的情况（标识码一致）
        //        List<LineNodeEx> arrLineNode = new List<LineNodeEx>();
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            if (i > 0)
        //            {
        //                if (m_arrLineNode[i].EntityID != m_arrLineNode[i - 1].EntityID)
        //                {
        //                    arrLineNode.Add(m_arrLineNode[i]);
        //                }
        //            }
        //            else
        //            {
        //                arrLineNode.Add(m_arrLineNode[i]);
        //            }
        //        }
        //        m_arrLineNode = arrLineNode;

        //        //合并线
        //        bool bAdd = false;//上一个处理好的对象是否已添加
        //        arrLineNode = new List<LineNodeEx>();
        //        for (int i = 0; i < m_arrLineNode.Count; i++)
        //        {
        //            if (m_arrLineNode[i].EntityID == 0//合并处理必须在同一个环内处理
        //                || m_arrLineNode[i].IsFromLine == true)//当前线节点是引用线
        //            {
        //                if (i > 0)
        //                {
        //                    //添加上一个对象
        //                    if (bAdd == false)
        //                    {
        //                        arrLineNode.Add(m_arrLineNode[i - 1]);
        //                    }
        //                }
        //                arrLineNode.Add(m_arrLineNode[i]);
        //                bAdd = true;
        //            }
        //            else
        //            {
        //                if (i > 0 && bAdd == false)
        //                {
        //                    //线所属的面必须一致（方向应该一致）
        //                    if (m_arrLineNode[i].OtherPolygonID == m_arrLineNode[i - 1].OtherPolygonID)
        //                    {
        //                        //合并线
        //                        m_arrLineNode[i - 1].SegmentNodes.AddRange(m_arrLineNode[i].SegmentNodes);
        //                    }
        //                    else
        //                    {
        //                        //添加上一个对象
        //                        arrLineNode.Add(m_arrLineNode[i - 1]);
        //                        bAdd = true;
        //                    }
        //                }
        //                if (i == m_arrLineNode.Count - 1)
        //                {
        //                    if (bAdd == false)
        //                    {
        //                        if (m_arrLineNode.Count > 1)
        //                        {
        //                            //最后一个对象与上一个对象已合并
        //                            arrLineNode.Add(m_arrLineNode[i - 1]);
        //                        }
        //                    }
        //                    else
        //                    {
        //                        //最后一个对象与上一个对象未合并
        //                        arrLineNode.Add(m_arrLineNode[i]);
        //                    }
        //                }
        //            }
        //        }
        //    }
        //}

	}//end PolygonNode

    public class PolygonNodeSimple : EntityNode
    {

        /// <summary>
        /// 标识点坐标
        /// </summary>
        public PointInfoNode LablePointInfoNode
        {
            get
            {
                return m_lablePointInfoNode;
            }
            set
            {
                m_lablePointInfoNode = value;
            }
        }
        private PointInfoNode m_lablePointInfoNode;

        /// <summary>
        /// 面的特征类型。其中：1表示由直接坐标表示的面对象，100表示由间接坐标表示的面对象。土地利用规划面状数据采用间接坐标交换。
        /// </summary>
        public int PolygonType
        {
            get
            {
                return m_nPolygonType;
            }
            set
            {
                m_nPolygonType = value;
            }
        }
        private int m_nPolygonType = 100;

        /// <summary>
        /// 间接坐标面的构成类型。21表示引用线对象构成的面，22表示引用面对象构成的面。
        /// </summary>
        public int ComposeType
        {
            get
            {
                return m_nComposeType;
            }
        }
        private int m_nComposeType = 21;

        /// <summary>
        /// 线对象标识码集合
        /// </summary>
        public List<int> LineNodes
        {
            get
            {
                return m_arrLineNode;
            }
            set
            {
                m_arrLineNode = value;
            }
        }
        private List<int> m_arrLineNode;

        /// <summary>
        /// 输出VCT节点
        /// </summary>
        public override string ToString()
        {
            ////过滤相同的线节点
            //List<LineNodeSimpleEx> arrLineNode = new List<LineNodeSimpleEx>();
            //for (int i = 0; i < m_arrLineNode.Count; i++)
            //{
            //    if (i == 0 || (i > 0 && m_arrLineNode[i].EntityID != m_arrLineNode[i - 1].EntityID))
            //    {
            //        arrLineNode.Add(m_arrLineNode[i]);
            //    }
            //}

            //输出VCT节点
            string strNode = base.ToString();
            strNode += "\r\n" + this.m_nPolygonType.ToString();
            strNode += "\r\n" + this.m_lablePointInfoNode.ToString();
            strNode += "\r\n" + this.m_nComposeType.ToString();
            strNode += "\r\n" + m_arrLineNode.Count.ToString();


            int k = 0;
            for (int i = 0; i < 0.125 * m_arrLineNode.Count; i++)//行数
            {
                strNode += "\r\n";
                for (int j = 0; k < m_arrLineNode.Count && j < 8; j++)
                {
                    if (j > 0)
                        strNode += HeadNode.Separator.ToString();
                    strNode += m_arrLineNode[k++].ToString();
                }
            }

            strNode += "\r\n0";

            return strNode;
        }
    }//end PolygonNode

}//end namespace FileData