///////////////////////////////////////////////////////////////////////////////
// Copyright © 2002, Open Design Alliance Inc. ("Open Design") 
// 
// This software is owned by Open Design, and may only be incorporated into 
// application programs owned by members of Open Design subject to a signed 
// Membership Agreement and Supplemental Software License Agreement with 
// Open Design. The structure and organization of this Software are the valuable 
// trade secrets of Open Design and its suppliers. The Software is also protected 
// by copyright law and international treaty provisions. You agree not to 
// modify, adapt, translate, reverse engineer, decompile, disassemble or 
// otherwise attempt to discover the source code of the Software. Application 
// programs incorporating this software must include the following statment 
// with their copyright notices:
//
//      DWGdirect © 2002 by Open Design Alliance Inc. All rights reserved. 
//
// By use of this software, you acknowledge and accept the terms of this 
// agreement.
///////////////////////////////////////////////////////////////////////////////



#ifndef OD_GETORUS_H
#define OD_GETORUS_H /* {Secret} */


#include "GeSurface.h"
#include "GeCircArc3d.h"
#include "OdPlatform.h"

#include "DD_PackPush.h"

/**
    Description:
    This class represents toroidal segments.

    Remarks:
    The torus is surface generated by revolving a circular *arc*
    about an axis of symmetry, where the *plane* of the circular *arc* 
    contains the axis of symmetry

    The torus is located in space by its *center*, which is a *point* on the axis of symmetry.  

    The *center* of the *circular* *arc* is at a distance of majorRadius from
    the *center* of the torus. The *radius* of the *circular* *arc* is the
    minorRadius.

    Parameter U is the longitude (about the axis of symmetry), which for a closed torus defaults
    to the range [-OdaPI, OdaPI).  Zero corresponds to the refAxis (which is
    a vector orthogonal to the axis of symmetry).  Applying the right
    hand rule along the symmetric axis defines the increasing direction
    for U.

    Parameter v parameterizes the circular tube, which
    for a closed circle defaults to the range [-OdaPI, OdaPI).  Applying the
    right hand rule along the refAxis X-axisOfSymmetry defines the
    increasing direction for v.

    The torus is *periodic* in U, v with a period of Oda2PI.
    [umin, umax] x [vmin, vmax] defines a four sided toroidal patch bounded
    by four circular arcs. Following constraints apply to the definition
    of a toroidal patch.

    o umin < umax and |umin - umax| <= Oda2PI.
    o vmin < vmax and |vmin - vmax| <= Oda2PI

    Library: Ge

   {group:OdGe_Classes} 
*/
class GE_TOOLKIT_EXPORT OdGeTorus : public OdGeSurface
{
public:
  /* Arguments:
    majorRadius (I) The major *radius* of this *torus*.
    minorRadius (I) The minor *radius* of this *torus*.
    center (I) The origin of the this *torus*.
    axisOfSymmetry (I) Axis of symmetry (rotation).
    refAxis (I) Defines angle 0 about the axis of symmetry.
    startAngleU (I) Start angle about the axis of symmetry.
    endAngleU (I) End angle about the axis of symmetry.
    startAngleV (I) Start angle about the tube.
    endAngleV (I) End angle about the tube.
    source (I) Object to be cloned.
  */
  OdGeTorus ()
  : m_minorRadius(0.5)
  {
    setAnglesInU(-OdaPI, OdaPI);
    setAnglesInV(-OdaPI, OdaPI);
  }

  OdGeTorus (
    double majorRadius, 
    double minorRadius,
    const OdGePoint3d& center, 
    const OdGeVector3d& axisOfSymmetry)
  {
    set(majorRadius, minorRadius, center, axisOfSymmetry);
  }

  OdGeTorus (
    double majorRadius, 
    double minorRadius,
    const OdGePoint3d& center, 
    const OdGeVector3d& axisOfSymmetry,
    const OdGeVector3d& refAxis,
    double startAngleU, 
    double endAngleU,
    double startAngleV, 
    double endAngleV)
  {
    set(majorRadius, minorRadius, center, axisOfSymmetry,
      refAxis, startAngleU, endAngleU,
      startAngleV, endAngleV);
  }
      
  OdGeTorus (
    const OdGeTorus& source)
  {
    operator = (source);
  }

  virtual OdGeEntity3d* copy () const;

  virtual bool isKindOf (
    OdGe::EntityId entType) const;
  virtual OdGe::EntityId type () const;

  virtual void getEnvelope (
    OdGeInterval& intrvlX, 
    OdGeInterval& intrvlY) const;
  virtual bool isClosedInU (
    const OdGeTol& tol = OdGeContext::gTol) const;
  virtual bool isClosedInV (
    const OdGeTol& tol = OdGeContext::gTol) const;

  // Geometric properties.
  //

  /**
    Description:
    Returns the major *radius* of this *torus*.
  */
  double majorRadius () const { return m_vArc.radius();}

  /**
    Description:
    Returns the minor *radius* of this *torus*.
  */
  double minorRadius () const
  { 
    if (isNormalReversed())
      return -m_minorRadius;
    return m_minorRadius;
  }
  /**
    Description:
    Returns the start and end angles about about the axis of symmetry.

    Arguments:
    startAngleU (O) Receives the angle about the axis of symmetry.
    endAngleU (O) Receives the end angle about the axis of symmetry.
  */
  void getAnglesInU (
    double& startAngleU, 
    double& endAngleU) const;

  /**
    Description:
    Returns the start and end angles about about the tube.

    Arguments:
    startAngleV (O) Receives the start angle about the tube.
    endAngleV (O) Receives the end angle about the tube.
  */
  void getAnglesInV (
    double& startAngleV, 
    double& endAngleV) const;

  /**
    Description:
    Returns the *center* of this *torus*.
  */
  OdGePoint3d center () const { return m_vArc.center();}

  /**
    Description:
    Returns the Axis of symmetry (rotation).
  */
  OdGeVector3d axisOfSymmetry () const { return m_vArc.normal();}

  /**
    Description:
    Returns the reference axis.
  */
  OdGeVector3d refAxis () const { return m_vArc.refVec();}

  /**
    Description:
    Returns true if and only if the *normal* to this surface
    is pointing outward.
  */
  bool isOuterNormal () const;

  /**
    Description:
    Sets the major *radius* of this *torus*.

    Arguments:
    majorRadius (I) The major *radius* of this *torus*.
  */
  OdGeTorus& setMajorRadius (
    double radius)
  { m_vArc.setRadius(radius);  return *this;}

  /**
    Description:
    Sets the minor *radius* of this *torus*.

    Arguments:
    minorRadius (I) The minor *radius* of this *torus*.
  */
  OdGeTorus& setMinorRadius (
    double radius)
  { m_minorRadius = radius; return *this;}

  /**
    Description:
    Sets the start and end angles about about the axis of symmetry.

    Arguments:
    startAngleU (I) Start angle about the axis of symmetry.
    endAngleU (I) End angle about the axis of symmetry.
  */
  OdGeTorus& setAnglesInU (
    double startAngleU, 
    double endAngleU);

  /**
    Description:
    Sets the start and end angles about about the tube.

    Arguments:
    startAngleV (I) Start angle about the tube.
    endAngleV (I) End angle about the tube.
  */
  OdGeTorus& setAnglesInV (
    double startAngleV, 
    double endAngleV);

  /**
    Description:
    Sets the parameters for this cylinder according to the arguments, 
    and returns a reference to this cylinder.

    Arguments:
    majorRadius (I) The major *radius* of this *torus*.
    minorRadius (I) The minor *radius* of this *torus*.
    center (I) The origin of the this *torus*.
    axisOfSymmetry (I) Axis of symmetry (rotation).
    refAxis (I) Defines angle 0 about the axis of symmetry.
    startAngleU (I) Start angle about the axis of symmetry.
    endAngleU (I) End angle about the axis of symmetry.
    startAngleV (I) Start angle about the tube.
    endAngleV (I) End angle about the tube.
  */
  OdGeTorus& set (
    double majorRadius, 
    double minorRadius,
    const OdGePoint3d& center,
    const OdGeVector3d& axisOfSymmetry)
    {
      m_vArc.set(center, axisOfSymmetry, majorRadius);
      m_minorRadius = minorRadius;
      setAnglesInU(-OdaPI, OdaPI);
      setAnglesInV(-OdaPI, OdaPI);
      return *this;
    }

  OdGeTorus& set (
    double majorRadius, 
    double minorRadius,
    const OdGePoint3d&  center,
    const OdGeVector3d& axisOfSymmetry,
    const OdGeVector3d& refAxis,
    double startAngleU, 
    double endAngleU,
    double startAngleV, 
    double endAngleV);

  // Shape Classification Functions

  /**
    Description:
    Returns true if and only if (0 < majorRadius < minorRadius), creating a solid with dimples at the
    axis of symmetry.

    Remarks:
    Exactly one of the following functions will be true for a given torus:

    o isApple() 
    o isDoughnut() 
    o isLemon() 
    o isVortex()
  */
  bool isApple () const;

  /**
    Description:
    Returns true if and only if (minorRadius <= 0) OR (majorRadius <= -minorRadius) 
  */
  bool isDegenerate () const;

  /**
    Description:
    Returns true if and only if (minorRadius <  majorRadius), creating a solid with a hole in the middle.

    Remarks:
    Exactly one of the following functions will be true for a given torus:

    o isApple() 
    o isDoughnut() 
    o isLemon() 
    o isVortex()
  */
  bool isDoughnut () const;

  /**
    Description:
    Returns true if and only if there is a hole in the torus.

    Remarks:
    Returns true if and only if |majorRadius| > |minorRadius| + 1e-10
  */
  bool isHollow () const;

  /**
    Description:
    Returns true if and only if (majorRadius < 0) and (|majorRadius| < minorRadius), producing
    a solid with points along the axis of symmetry.

    Remarks:
    Exactly one of the following functions will be true for a given torus:

    o isApple() 
    o isDoughnut() 
    o isLemon() 
    o isVortex()
  */
  bool isLemon () const;

  /**
    Description:
    Returns true if and only if (minorRadius == majorRadius), producing a donut.
    with a zero-radius hole.

    Remarks:
    Exactly one of the following functions will be true for a given torus:

    o isApple() 
    o isDoughnut() 
    o isLemon() 
    o isVortex()
  */
  bool isVortex () const;

  // Assignment operator.
  //
  
  OdGeTorus& operator = (
    const OdGeTorus& torus)
  {
    m_vArc = torus.m_vArc;
    m_minorRadius = torus.m_minorRadius;
    m_startAngleU = torus.m_startAngleU;
    m_endAngleU = torus.m_endAngleU;
    return *this;
  }

  /**
    Description:
    Returns true if and only if this cylinder intersects with
    a line entity, and returns the number of intersections and the
    points of intersection.

    Arguments:
    lineEnt (I) Any 3D *line* entity.
    numInt (O) Receives the number of intersections.
    p1 (O) Receives the first intersection *point*.
    p2 (O) Receives the second intersection *point*.
    p3 (O) Receives the third intersection *point*.
    p4 (O) Receives the fourth intersection *point*.
    tol (I) Geometric tolerance.

    Remarks:
    o p1 is valid if and only if numInt >= 1.
    o p2 is valid if and only if numInt >= 2.
    o p3 is valid if and only if numInt >= 3.
    o p4 is valid if and only if numInt >= 4.
  */
  bool intersectWith (
    const OdGeLinearEnt3d& linEnt, 
    int& numInt,
    OdGePoint3d& p1, 
    OdGePoint3d& p2,
    OdGePoint3d& p3, 
    OdGePoint3d& p4,
    const OdGeTol& tol = OdGeContext::gTol) const;

  virtual OdGePoint2d paramOf(
    const OdGePoint3d& point,
    const OdGeTol& tol = OdGeContext::gTol) const;

  virtual OdGePoint3d evalPoint(
    const OdGePoint2d& param) const;
  virtual OdGePoint3d evalPoint (
    const OdGePoint2d& param, 
    int numDeriv,
    OdGeVector3dArray& derivatives, 
    OdGeVector3d& normal) const;


  DD_USING(OdGeSurface::evalPoint);

protected:
  OdGeCircArc3d m_vArc;
  double m_minorRadius;
  double m_startAngleU;
  double m_endAngleU;
};



#include "DD_PackPop.h"

#endif // OD_GETORUS_H


